<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WideChat Call</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0B141B; color: white; font-family: Arial, sans-serif; overflow: hidden; }
        #localVideo, #remoteVideo { width: 100%; height: 100vh; object-fit: cover; }
        #localVideo { position: absolute; top: 20px; right: 20px; width: 120px; height: 160px; border-radius: 10px; z-index: 10; border: 2px solid #00A884; }
        .controls { position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%); display: flex; gap: 20px; z-index: 10; }
        .control-btn { width: 60px; height: 60px; border-radius: 50%; border: none; color: white; font-size: 24px; cursor: pointer; background: rgba(255,255,255,0.2); }
        .control-btn.active { background: #f44336; }
        .end { background: #f44336; width: 70px; height: 70px; }
        .status { position: absolute; top: 20px; left: 20px; z-index: 10; background: rgba(0,0,0,0.5); padding: 8px 12px; border-radius: 20px; }
        .voice-only { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; }
        .avatar { width: 150px; height: 150px; border-radius: 50%; background: #00A884; display: flex; align-items: center; justify-content: center; font-size: 60px; margin-bottom: 20px; }
        .contact-name { font-size: 24px; margin-bottom: 10px; }
    </style>
</head>
<body>
    <div class="status" id="status">Connecting...</div>
    <video id="remoteVideo" autoplay playsinline style="display: none;"></video>
    <video id="localVideo" autoplay playsinline muted style="display: none;"></video>
    
    <div id="voiceInterface" class="voice-only" style="display: none;">
        <div class="avatar">ðŸ‘¤</div>
        <div class="contact-name" id="contactName">Contact</div>
        <div id="callStatus">Connecting...</div>
    </div>
    
    <div class="controls">
        <button class="control-btn mute" id="muteBtn" onclick="toggleMute()">ðŸŽ¤</button>
        <button class="control-btn end" onclick="endCall()">ðŸ“ž</button>
        <button class="control-btn video" id="videoBtn" onclick="toggleVideo()" style="display: none;">ðŸ“¹</button>
        <button class="control-btn" id="switchBtn" onclick="switchCamera()" style="display: none;">ðŸ”„</button>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script src="https://unpkg.com/simple-peer@9.11.1/simplepeer.min.js"></script>
    <script>
        const urlParams = new URLSearchParams(window.location.search);
        const callId = urlParams.get('callId');
        const callType = urlParams.get('type') || 'voice';
        const isIncoming = urlParams.get('incoming') === 'true';
        const token = urlParams.get('token');
        const contactName = urlParams.get('contactName') || 'Contact';

        // Validate required parameters
        if (!callId) {
            document.getElementById('status').textContent = 'Error: Call ID not found';
            document.getElementById('callStatus').textContent = 'Error: Call ID not found';
            console.error('Missing callId parameter');
            return;
        }

        if (!token) {
            document.getElementById('status').textContent = 'Error: Authentication token not found';
            document.getElementById('callStatus').textContent = 'Error: Authentication token not found';
            console.error('Missing token parameter');
            return;
        }

        console.log('Call parameters:', { callId, callType, isIncoming, contactName });

        let socket;
        let localStream;
        let remoteStream;
        let peer;
        let isMuted = false;
        let isVideoEnabled = callType === 'video';
        let currentUserId = 'user1';
        let targetUserId = 'user2';

        class WebRTCCall {
            constructor() {
                this.peer = null;
                this.localStream = null;
                this.remoteStream = null;
            }

            async initializeCall() {
                try {
                    this.initInterface();
                    
                    // Validate token and get user details
                    if (!token) {
                        throw new Error('Authentication token is required');
                    }
                    
                    // Initialize socket with authentication
                    socket = io({
                        auth: {
                            token: token
                        }
                    });
                    
                    // Get current user ID from token (simplified - in production, decode JWT)
                    currentUserId = 'current_user'; // This should be extracted from token
                    targetUserId = 'target_user'; // This should come from call data
                    
                    socket.emit('join_room', { user_id: currentUserId });
                    
                    const constraints = {
                        audio: true,
                        video: isVideoEnabled ? {
                            facingMode: 'user',
                            width: { ideal: 1280 },
                            height: { ideal: 720 }
                        } : false
                    };
                    
                    this.localStream = await navigator.mediaDevices.getUserMedia(constraints);
                    
                    if (isVideoEnabled) {
                        document.getElementById('localVideo').srcObject = this.localStream;
                        document.getElementById('localVideo').style.display = 'block';
                    }

                    this.peer = new SimplePeer({
                        initiator: !isIncoming,
                        trickle: false,
                        stream: this.localStream,
                        config: {
                            iceServers: [
                                { urls: 'stun:stun.l.google.com:19302' },
                                { urls: 'stun:stun1.l.google.com:19302' }
                            ]
                        }
                    });

                    this.setupPeerEvents();
                    this.setupSocketEvents();

                    this.updateStatus('Call in progress');

                } catch (error) {
                    console.error('Error initializing call:', error);
                    this.updateStatus(`Connection failed: ${error.message}`);
                }
            }

            initInterface() {
                document.getElementById('contactName').textContent = contactName;
                
                if (callType === 'video') {
                    document.getElementById('remoteVideo').style.display = 'block';
                    document.getElementById('localVideo').style.display = 'block';
                    document.getElementById('videoBtn').style.display = 'inline-block';
                    document.getElementById('switchBtn').style.display = 'inline-block';
                    document.getElementById('voiceInterface').style.display = 'none';
                } else {
                    document.getElementById('voiceInterface').style.display = 'flex';
                    document.getElementById('remoteVideo').style.display = 'none';
                    document.getElementById('localVideo').style.display = 'none';
                }
            }

            setupPeerEvents() {
                this.peer.on('signal', (data) => {
                    console.log('Sending WebRTC signal:', data.type);
                    socket.emit('webrtc_signal', {
                        target_user: targetUserId,
                        signal: data,
                        call_id: callId,
                        from_user: currentUserId
                    });
                });

                this.peer.on('stream', (stream) => {
                    console.log('Received remote stream');
                    this.remoteStream = stream;
                    if (isVideoEnabled) {
                        document.getElementById('remoteVideo').srcObject = stream;
                    }
                    this.updateStatus('Connected');
                });

                this.peer.on('connect', () => {
                    console.log('WebRTC connection established');
                });

                this.peer.on('close', () => {
                    console.log('WebRTC connection closed');
                    this.cleanup();
                });

                this.peer.on('error', (error) => {
                    console.error('WebRTC error:', error);
                    this.updateStatus('Connection error');
                });
            }

            setupSocketEvents() {
                socket.on('webrtc_signal', (data) => {
                    console.log('Received WebRTC signal:', data.signal.type);
                    if (this.peer && !this.peer.destroyed) {
                        this.peer.signal(data.signal);
                    }
                });

                socket.on('call_ended', () => {
                    this.endCall();
                });
            }

            updateStatus(status) {
                document.getElementById('status').textContent = status;
                document.getElementById('callStatus').textContent = status;
            }

            toggleMute() {
                if (this.localStream) {
                    const audioTrack = this.localStream.getAudioTracks()[0];
                    if (audioTrack) {
                        audioTrack.enabled = !audioTrack.enabled;
                        isMuted = !audioTrack.enabled;
                        document.getElementById('muteBtn').classList.toggle('active', isMuted);
                        document.getElementById('muteBtn').textContent = isMuted ? 'ðŸ”‡' : 'ðŸŽ¤';
                    }
                }
            }

            toggleVideo() {
                if (this.localStream && callType === 'video') {
                    const videoTrack = this.localStream.getVideoTracks()[0];
                    if (videoTrack) {
                        videoTrack.enabled = !videoTrack.enabled;
                        isVideoEnabled = videoTrack.enabled;
                        document.getElementById('videoBtn').classList.toggle('active', !isVideoEnabled);
                        document.getElementById('videoBtn').textContent = isVideoEnabled ? 'ðŸ“¹' : 'ðŸ“·';
                    }
                }
            }

            async switchCamera() {
                if (!isVideoEnabled || !this.localStream) return;
                
                try {
                    const videoTrack = this.localStream.getVideoTracks()[0];
                    const constraints = {
                        audio: false,
                        video: {
                            facingMode: videoTrack.getSettings().facingMode === 'user' ? 'environment' : 'user'
                        }
                    };
                    
                    const newStream = await navigator.mediaDevices.getUserMedia(constraints);
                    const newVideoTrack = newStream.getVideoTracks()[0];
                    
                    if (this.peer && !this.peer.destroyed) {
                        const sender = this.peer._pc.getSenders().find(s => s.track && s.track.kind === 'video');
                        if (sender) {
                            await sender.replaceTrack(newVideoTrack);
                        }
                    }
                    
                    this.localStream.removeTrack(videoTrack);
                    this.localStream.addTrack(newVideoTrack);
                    videoTrack.stop();
                    
                    document.getElementById('localVideo').srcObject = this.localStream;
                } catch (error) {
                    console.error('Failed to switch camera:', error);
                }
            }

            endCall() {
                this.cleanup();
                if (window.CallHandler) {
                    window.CallHandler.postMessage('call_ended');
                }
                window.close();
            }

            cleanup() {
                if (this.localStream) {
                    this.localStream.getTracks().forEach(track => track.stop());
                }
                if (this.peer) {
                    this.peer.destroy();
                }
                if (socket) {
                    socket.emit('end_call', { call_id: callId });
                    socket.disconnect();
                }
            }
        }

        const webrtcCall = new WebRTCCall();

        window.toggleMute = () => webrtcCall.toggleMute();
        window.toggleVideo = () => webrtcCall.toggleVideo();
        window.switchCamera = () => webrtcCall.switchCamera();
        window.endCall = () => webrtcCall.endCall();

        webrtcCall.initializeCall();
    </script>
</body>
</html>
